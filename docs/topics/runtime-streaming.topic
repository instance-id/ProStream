<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       id="runtime-streaming" title="Runtime Streaming Systems">

    <title>Runtime Streaming Systems</title>

    <tldr>
        <p>ProStream's runtime streaming systems use Unity's DOTS/ECS for high-performance, distance-based scene streaming.</p>
    </tldr>

    <chapter title="Overview" id="overview">
        <p>ProStream's runtime streaming systems are built on Unity's DOTS (Data-Oriented Technology Stack) and use ECS (Entity Component System) for high-performance, distance-based scene streaming. These systems automatically load and unload SubScenes based on proximity to a loading trigger
            (typically the player or camera).</p>

        <p>
            <format style="bold">Key Runtime Components:</format>
        </p>
        <list>
            <li>
                <format style="bold">SubSceneLoadingSystem</format>
                - Handles loading SubScenes and sections
            </li>
            <li>
                <format style="bold">SubSceneUnloadingSystem</format>
                - Handles unloading SubScenes and sections
            </li>
            <li>
                <format style="bold">StreamingManager</format>
                - Coordinates streaming operations
            </li>
            <li>
                <format style="bold">ProStreamSystem</format>
                - Base system infrastructure
            </li>
            <li>
                <format style="bold">Loading Trigger</format>
                - Reference position for distance calculations (GameObject)
            </li>
        </list>
    </chapter>

    <chapter title="Core Concepts" id="core-concepts">
        <chapter title="Distance-Based Streaming" id="distance-based-streaming">
            <p>ProStream calculates the distance between the
                <format style="bold">Loading Trigger</format>
                (your player/camera) and each SubScene. When the distance falls within configured thresholds, sections are loaded or unloaded.
            </p>

            <code-block lang="text" collapsible="true" collapsed-title="Distance Calculation Example">
Player Position: (0, 0, 0)
SubScene Position: (100, 0, 50)
Distance: ~111 units

If Section "LargeObjects" loads at 150m:
→ Section IS loaded (111m &lt; 150m)

If Section "SmallObjects" loads at 50m:
→ Section NOT loaded (111m &gt; 50m)
            </code-block>
        </chapter>

        <chapter title="Section-Based Loading" id="section-based-loading">
            <p>Each SubScene contains multiple
                <format style="bold">sections</format>
                (Ground, LargeObjects, SmallObjects, etc.). Sections can load/unload independently based on their configured distances.
            </p>

            <p>
                <format style="bold">Benefits:</format>
            </p>
            <list>
                <li>Fine-grained control over what loads when</li>
                <li>Reduced memory usage (only load what's visible)</li>
                <li>Improved performance (fewer objects to process)</li>
                <li>Seamless streaming (no loading screens)</li>
            </list>
        </chapter>
    </chapter>

    <chapter title="SubSceneLoadingSystem" id="subscene-loading-system">
        <p>
            <format style="bold">Location:</format>
            <path>Runtime/Scripts/Streaming/SubSceneLoadingSystem.cs</path>
            (+ Methods.cs, State.cs)
        </p>

        <chapter title="Purpose" id="loading-purpose">
            <p>Manages the loading of SubScenes and their sections based on distance from the loading trigger.</p>
        </chapter>

        <chapter title="How It Works" id="loading-how-it-works">
            <code-block lang="text">
Every Frame (Update):

1. Calculate distance to each SubScene
2. Determine which sections should be loaded
3. Queue loading requests for new sections
4. Execute loading jobs asynchronously
5. Update loaded section tracking
            </code-block>
        </chapter>

        <chapter title="State Machine" id="loading-state-machine" collapsible="true">
            <p>The loading system maintains internal states for each SubScene:</p>

            <deflist>
                <def id="unloaded" title="Unloaded">
                    <p>SubScene not in memory</p>
                </def>
                <def id="loading" title="Loading">
                    <p>SubScene being loaded</p>
                </def>
                <def id="loaded" title="Loaded">
                    <p>SubScene fully loaded and active</p>
                </def>
                <def id="streaming" title="Streaming">
                    <p>Sections loading/unloading dynamically</p>
                </def>
            </deflist>

            <code-block lang="text">
Unloaded → Loading → Loaded → Streaming
↓ ↓
←──────────────────────────────
(Distance exceeds threshold)
            </code-block>
        </chapter>

        <chapter title="ECS Queries" id="loading-ecs-queries" collapsible="true">
            <p>The system uses ECS queries to efficiently process SubScenes:</p>

            <code-block lang="c#">
// Filename: Runtime/Scripts/Streaming/SubSceneLoadingSystem.cs
// Class: SubSceneLoadingSystem

// Query for SubScenes that need loading
EntityQuery loadingQuery = GetEntityQuery(
    ComponentType.ReadOnly&lt;SubSceneData&gt;(),
    ComponentType.ReadOnly&lt;WorldTransform&gt;(),
    ComponentType.Exclude&lt;LoadedSection&gt;()
);

// Query for SubScenes with sections to load
EntityQuery sectionQuery = GetEntityQuery(
    ComponentType.ReadOnly&lt;SceneSection&gt;(),
    ComponentType.ReadOnly&lt;SectionDistance&gt;()
);
            </code-block>
        </chapter>

        <chapter title="Jobs for Performance" id="loading-jobs" collapsible="true">
            <p>Loading operations run as parallel jobs using Unity's Job System with Burst compilation:</p>

            <code-block lang="c#">
// Filename: Runtime/Scripts/Streaming/GameObjectSceneJob.cs
// Struct: GameObjectSceneJob

[BurstCompile]
public struct DistanceCalculationJob : IJobParallelFor
{
    [ReadOnly] public float3 loadingTriggerPosition;
    [ReadOnly] public NativeArray&lt;float3&gt; subScenePositions;
    public NativeArray&lt;float&gt; distances;
    
    public void Execute(int index)
    {
        distances[index] = math.distance(
            loadingTriggerPosition, 
            subScenePositions[index]
        );
    }
}
            </code-block>

            <include from="common-snippets.md" element-id="burst-compiled"/>
        </chapter>
    </chapter>

    <chapter title="SubSceneUnloadingSystem" id="subscene-unloading-system">
        <p>
            <format style="bold">Location:</format>
            <path>Runtime/Scripts/Streaming/SubSceneUnloadingSystem.cs</path>
            (+ Methods.cs, State.cs)
        </p>

        <chapter title="Purpose" id="unloading-purpose">
            <p>Manages the unloading of SubScenes and sections when they exceed distance thresholds or when triggered manually.</p>
        </chapter>

        <chapter title="How It Works" id="unloading-how-it-works">
            <code-block lang="text">
Every Frame (Update):

1. Check loaded sections against distance thresholds
2. Identify sections to unload
3. Queue unloading requests
4. Execute unloading jobs
5. Release resources
6. Update tracking data
            </code-block>
        </chapter>

        <chapter title="Unloading Strategy" id="unloading-strategy" collapsible="true">
            <p>
                <format style="bold">Hysteresis:</format>
                ProStream uses slightly different thresholds for loading vs unloading to prevent "flickering" (rapid load/unload cycles).
            </p>

            <tabs>
                <tab title="Example">
                    <list>
                        <li>
                            <format style="bold">Load at:</format>
                            150m
                        </li>
                        <li>
                            <format style="bold">Unload at:</format>
                            160m (10m hysteresis buffer)
                        </li>
                    </list>
                    <p>This prevents objects from loading/unloading repeatedly when the player hovers around the threshold.</p>
                </tab>
                <tab title="Configuration">
                    <p>Hysteresis buffer can be configured in StreamingManager settings.</p>
                    <code-block lang="c#">
// Filename: YourGameCode.cs
// Method: ConfigureHysteresis

public void ConfigureHysteresis(float buffer)
{
    StreamingManager.Instance.HysteresisBuffer = buffer;
}
                    </code-block>
                </tab>
            </tabs>
        </chapter>

        <chapter title="Memory Management" id="memory-management" collapsible="true">
            <p>The unloading system ensures proper cleanup:</p>
            <list>
                <li>Destroys entity data</li>
                <li>Releases scene references</li>
                <li>Clears cached data</li>
                <li>Triggers garbage collection hints (when appropriate)</li>
            </list>
        </chapter>
    </chapter>

    <chapter title="StreamingManager" id="streaming-manager">
        <p>
            <format style="bold">Location:</format>
            <path>Runtime/Scripts/MonoBehaviour/StreamingManager.cs</path>
        </p>

        <chapter title="Purpose" id="manager-purpose">
            <p>High-level coordinator for all streaming operations. Acts as the bridge between MonoBehaviour world and ECS systems.</p>
        </chapter>

        <chapter title="Key Responsibilities" id="manager-responsibilities" collapsible="true" default-state="expanded">
            <deflist>
                <def title="Loading Trigger Management">
                    <list>
                        <li>Tracks the reference position (player/camera)</li>
                        <li>Updates trigger position every frame</li>
                        <li>Provides position to ECS systems</li>
                    </list>
                </def>
                <def title="System Coordination">
                    <list>
                        <li>Enables/disables streaming systems</li>
                        <li>Controls streaming behavior</li>
                        <li>Handles streaming state</li>
                    </list>
                </def>
                <def title="Configuration Management">
                    <list>
                        <li>Applies streaming settings</li>
                        <li>Manages distance thresholds</li>
                        <li>Handles persistent sections</li>
                    </list>
                </def>
                <def title="Debug Visualization">
                    <list>
                        <li>Displays streaming boundaries (gizmos)</li>
                        <li>Shows loaded/unloaded sections</li>
                        <li>Provides runtime feedback</li>
                    </list>
                </def>
            </deflist>
        </chapter>

        <chapter title="Setup" id="manager-setup">
            <p>StreamingManager is
                <format style="bold">automatically created</format>
                after SubScene creation. You can also add it manually.
            </p>

            <procedure title="Loading Trigger Configuration" id="configure-trigger">
                <p>
                    <format style="bold">In Inspector:</format>
                </p>
                <step>Select StreamingManager GameObject</step>
                <step>Assign your Player/Camera to
                    <control>Loading Trigger</control>
                    field
                </step>

                <p>
                    <format style="bold">In Code:</format>
                </p>
               
                <code-block lang="c#">
// Filename: YourPlayerController.cs
// Method: Start

private void Start()
{
    if (StreamingManager.Instance != null)
    {
        StreamingManager.Instance.SetLoadingTrigger(this.transform);
    }
}
                </code-block>

            </procedure>
        </chapter>
    </chapter>

    <chapter title="Distance Calculation" id="distance-calculation" collapsible="true">
        <chapter title="Proximity Detection" id="proximity-detection">
            <p>Distance is calculated using Unity.Mathematics for performance:</p>

            <code-block lang="c#">
// Filename: Runtime/Scripts/Streaming/DistanceCalculator.cs
// Method: CalculateDistance

public static float CalculateDistance(float3 from, float3 to)
{
    return math.distance(from, to);
}

// Optimized squared distance (avoids sqrt when possible)
public static float CalculateDistanceSq(float3 from, float3 to)
{
    return math.distancesq(from, to);
}
</code-block>
        </chapter>

        <chapter title="Performance Optimization" id="distance-optimization">
            <p>
                <format style="bold">Distance checks use squared distance</format>
                when comparing thresholds to avoid expensive square root operations:
            </p>

            <code-block lang="c#">
// Filename: Runtime/Scripts/Streaming/SubSceneLoadingSystem.Methods.cs
// Method: ShouldLoad

private bool ShouldLoad(float3 triggerPos, float3 subScenePos, float threshold)
{
    float thresholdSq = threshold * threshold;
    float distanceSq = math.distancesq(triggerPos, subScenePos);
    return distanceSq &lt;= thresholdSq;
}
</code-block>

        </chapter>

        <chapter title="LOD-Style Distance Bands" id="distance-bands">
            <p>Sections can be configured with multiple distance bands similar to LOD levels:</p>

            <table>
                <tr>
                    <td>Band</td>
                    <td>Distance</td>
                    <td>Detail Level</td>
                </tr>
                <tr>
                    <td>Band 0</td>
                    <td>0-50m</td>
                    <td>Full detail, all sections loaded</td>
                </tr>
                <tr>
                    <td>Band 1</td>
                    <td>50-150m</td>
                    <td>Medium detail, large objects only</td>
                </tr>
                <tr>
                    <td>Band 2</td>
                    <td>150-300m</td>
                    <td>Low detail, terrain/large structures only</td>
                </tr>
                <tr>
                    <td>Band 3</td>
                    <td>300m+</td>
                    <td>Nothing loaded</td>
                </tr>
            </table>
        </chapter>
    </chapter>

    <chapter title="Visualization and Debugging" id="visualization-debugging">
        <p>
            <format style="bold">Location:</format>
            <path>Runtime/Scripts/Streaming/Drawing/DebugDistanceSystem/*</path>
        </p>

        <chapter title="Features" id="debug-features">
            <list>
                <li>
                    <format style="bold">Distance rings</format>
                    around loading trigger
                </li>
                <li>
                    <format style="bold">SubScene bounds</format>
                    visualization
                </li>
                <li>
                    <format style="bold">Loaded/unloaded</format>
                    color coding
                </li>
                <li>
                    <format style="bold">Section status</format>
                    indicators
                </li>
                <li>
                    <format style="bold">Performance metrics</format>
                    display
                </li>
            </list>
        </chapter>

        <procedure title="Enabling Debug Visualization" id="enable-debug">
            <tabs>
                <tab id="visualization" title="In Code">
                    
<code-block lang="c#">
// Filename: Runtime/Scripts/Streaming/Drawing/DebugDistanceSystem/DebugDistanceSystem.cs
// Property: DebugDistanceSystem.Enabled

DebugDistanceSystem.Instance.Enabled = true;
</code-block>

                </tab>
                <tab id="visualization2" title="In Editor">
                    <list>
                        <li>Select StreamingManager</li>
                        <li>Check
                            <control>Enable Debug Visualization</control>
                        </li>
                    </list>
                </tab>
            </tabs>
        </procedure>

        <chapter title="Visualization Features" id="visualization-features" collapsible="true">
            <deflist>
                <def id="distance_rings" title="Distance Rings">
                    <list>
                        <li>Shows configured distance thresholds</li>
                        <li>Updates as loading trigger moves</li>
                        <li>Color-coded by section type</li>
                    </list>
                </def>
                <def id="subscene_bounds" title="SubScene Bounds">
                    <list>
                        <li>Wireframe boxes around each SubScene</li>
                        <li>
                            <format color="Green">Green</format>
                            = Loaded
                        </li>
                        <li>
                            <format color="Red">Red</format>
                            = Unloaded
                        </li>
                        <li>
                            <format color="Yellow">Yellow</format>
                            = Loading/Unloading
                        </li>
                    </list>
                </def>
                <def id="section_indicators" title="Section Indicators">
                    <list>
                        <li>Shows which sections are active</li>
                        <li>Displays section load state</li>
                        <li>Indicates section priority</li>
                    </list>
                </def>
            </deflist>
        </chapter>
    </chapter>

    <chapter title="Runtime Performance" id="runtime-performance">
        <chapter title="Optimization Strategies" id="optimization-strategies">
            <deflist>
                <def id="" title="1. Job System + Burst">
                    <list>
                        <li>All heavy calculations run as Burst-compiled jobs</li>
                        <li>Parallel processing across CPU cores</li>
                        <li>Minimal main thread overhead</li>
                    </list>
                </def>
                <def title="2. ECS Queries">
                    <list>
                        <li>Efficient data access patterns</li>
                        <li>Cache-friendly memory layout</li>
                        <li>Minimal allocations</li>
                    </list>
                </def>
                <def title="3. Spatial Indexing">
                    <list>
                        <li>QuadTree for spatial queries</li>
                        <li>O(log n) nearest-neighbor lookups</li>
                        <li>Efficient range queries</li>
                    </list>
                </def>
                <def title="4. Incremental Updates">
                    <list>
                        <li>Not all SubScenes checked every frame</li>
                        <li>Priority system for distance checks</li>
                        <li>Staggered updates for distant SubScenes</li>
                    </list>
                </def>
            </deflist>
        </chapter>

        <chapter title="Performance Metrics" id="performance-metrics" collapsible="true">
            <p>
                <format style="bold">Typical Overhead (optimized scene):</format>
            </p>
            <table>
                <tr>
                    <td>Operation</td>
                    <td>Time per Frame</td>
                </tr>
                <tr>
                    <td>Distance calculation</td>
                    <td>&lt;0.1ms</td>
                </tr>
                <tr>
                    <td>Loading decision</td>
                    <td>&lt;0.05ms</td>
                </tr>
                <tr>
                    <td>Section management</td>
                    <td>&lt;0.1ms</td>
                </tr>
                <tr>
                    <td>
                        <format style="bold">Total streaming overhead</format>
                    </td>
                    <td>
                        <format style="bold">&lt;0.5ms</format>
                    </td>
                </tr>
            </table>

            <p>
                <format style="bold">Scalability:</format>
            </p>
            <list>
                <li>100 SubScenes: ~0.5ms overhead</li>
                <li>500 SubScenes: ~1-2ms overhead</li>
                <li>1000+ SubScenes: Consider chunking/LOD strategies</li>
            </list>
        </chapter>
    </chapter>

    <chapter title="Configuration at Runtime" id="runtime-configuration" collapsible="true">
        <tabs>
            <tab title="Adjust Distances">
                
<code-block lang="c#">
// Filename: YourGameCode.cs
// Method: AdjustStreamingDistance

public void AdjustStreamingDistance(string sectionName, float newDistance)
{
    var layerData = FindLayerData(sectionName);
    if (layerData != null)
    {
        layerData.LoadDistance = newDistance;
        StreamingManager.Instance.RefreshDistances();
    }
}
</code-block>
            </tab>
            <tab title="Toggle Streaming">
                
<code-block lang="c#">
// Filename: YourGameCode.cs
// Method: ToggleStreaming

public void ToggleStreaming(bool enabled)
{
    StreamingManager.Instance.StreamingEnabled = enabled;
}
</code-block>

            </tab>
            <tab title="Preload Areas">
                
<code-block lang="c#">
// Filename: YourGameCode.cs
// Method: PreloadArea

public void PreloadArea(Vector3 position, float radius)
{
    StreamingManager.Instance.PreloadArea(position, radius);
}
</code-block>
            </tab>
        </tabs>
    </chapter>

    <chapter title="Best Practices" id="best-practices">
        <tabs>
            <tab title="Loading Trigger">
                <list>
                    <li>Use player position, not camera (for third-person games)</li>
                    <li>Update trigger position every frame</li>
                    <li>Consider multiple triggers for split-screen</li>
                    <li>Smooth trigger movement to prevent jitter</li>
                </list>
            </tab>
            <tab title="Distance Config">
                <list>
                    <li>Use conservative distances (larger = smoother, more memory)</li>
                    <li>Test on target hardware</li>
                    <li>Balance visual quality vs memory budget</li>
                    <li>Use hysteresis to prevent flickering</li>
                </list>
            </tab>
            <tab title="Section Organization">
                <list>
                    <li>Put critical objects in persistent sections</li>
                    <li>Group objects by importance/detail level</li>
                    <li>Consider visual pop-in (load larger objects first)</li>
                    <li>Profile and optimize section sizes</li>
                </list>
            </tab>
            <tab title="Performance">
                <list>
                    <li>Monitor memory usage in Profiler</li>
                    <li>Check streaming overhead (should be &lt;1ms typically)</li>
                    <li>Use debug visualization during development</li>
                    <li>Test streaming behavior with movement patterns</li>
                </list>
            </tab>
        </tabs>
    </chapter>

    <chapter title="Troubleshooting" id="troubleshooting">
        <deflist>
            <def title="Sections Not Loading">
                <p>
                    <format style="bold">Symptoms:</format>
                    SubScenes never load even when close
                </p>
                <p>
                    <format style="bold">Check:</format>
                </p>
                <list>
                    <li>StreamingManager exists in scene</li>
                    <li>Loading trigger is assigned and valid</li>
                    <li>Streaming is enabled (<code>StreamingManager.StreamingEnabled = true</code>)</li>
                    <li>Distance thresholds are appropriate for scene scale</li>
                    <li>SubScene entities are registered with streaming systems</li>
                </list>
            </def>

            <def title="Pop-In/Pop-Out">
                <p>
                    <format style="bold">Symptoms:</format>
                    Objects appear/disappear abruptly
                </p>
                <p>
                    <format style="bold">Solutions:</format>
                </p>
                <list>
                    <li>Increase loading distances</li>
                    <li>Add hysteresis buffer (load at X, unload at X+10)</li>
                    <li>Use transition/fade effects</li>
                    <li>Load larger objects farther out</li>
                    <li>Consider LOD integration</li>
                </list>
            </def>

            <def title="Performance Spikes">
                <p>
                    <format style="bold">Symptoms:</format>
                    Frame drops when sections load/unload
                </p>
                <p>
                    <format style="bold">Causes:</format>
                    Too many objects in single section, synchronous loading, heavy scripts
                </p>
                <p>
                    <format style="bold">Solutions:</format>
                </p>
                <list>
                    <li>Split large sections into smaller ones</li>
                    <li>Ensure async loading is enabled</li>
                    <li>Use object pooling for frequently loaded objects</li>
                    <li>Spread initialization over multiple frames</li>
                    <li>Profile to identify bottlenecks</li>
                </list>
            </def>

            <def title="Memory Leaks">
                <p>
                    <format style="bold">Symptoms:</format>
                    Memory usage grows over time
                </p>
                <p>
                    <format style="bold">Check:</format>
                </p>
                <list>
                    <li>Sections properly unloading</li>
                    <li>No lingering references to unloaded objects</li>
                    <li>Event handlers unsubscribed</li>
                    <li>Pooled objects returned properly</li>
                </list>
            </def>
        </deflist>

        <p>For more issues, see <a href="troubleshooting.md">Troubleshooting Guide</a></p>
    </chapter>

    <seealso>
        <category ref="setup">
            <a href="streaming-layers.md"> Streaming Layers Configuration</a>
            <a href="process-subscenes.md"> SubScene Creation Process</a>
            <a href="standard_workflow.topic"> Quick Start Guide</a>
        </category>
        <category ref="core-concepts">
            <a href="basic-workflow.md"> Basic Workflow</a>
            <a href="scene-connector.md"> SceneConnector Component</a>
        </category>
    </seealso>
</topic>
